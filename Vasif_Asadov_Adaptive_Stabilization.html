<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Vasif Asadov">

<title>Adaptive Stabilization</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Vasif_Asadov_Adaptive_Stabilization_files/libs/clipboard/clipboard.min.js"></script>
<script src="Vasif_Asadov_Adaptive_Stabilization_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="Vasif_Asadov_Adaptive_Stabilization_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="Vasif_Asadov_Adaptive_Stabilization_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="Vasif_Asadov_Adaptive_Stabilization_files/libs/quarto-html/popper.min.js"></script>
<script src="Vasif_Asadov_Adaptive_Stabilization_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Vasif_Asadov_Adaptive_Stabilization_files/libs/quarto-html/anchor.min.js"></script>
<link href="Vasif_Asadov_Adaptive_Stabilization_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Vasif_Asadov_Adaptive_Stabilization_files/libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Vasif_Asadov_Adaptive_Stabilization_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Vasif_Asadov_Adaptive_Stabilization_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Vasif_Asadov_Adaptive_Stabilization_files/libs/bootstrap/bootstrap-9e3ffae467580fdb927a41352e75a2e0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Adaptive Stabilization</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Vasif Asadov </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>

<nav id="TOC" role="doc-toc">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#giriş.-basit-örnek" id="toc-giriş.-basit-örnek">5.1. Giriş. Basit Örnek</a>
  <ul>
  <li><a href="#theorem-5.1" id="toc-theorem-5.1">Theorem 5.1</a></li>
  </ul></li>
  <li><a href="#adaptive-stabilization.-tuning-functions." id="toc-adaptive-stabilization.-tuning-functions.">5.2. Adaptive stabilization. Tuning functions.</a>
  <ul>
  <li><a href="#theorem-5.2." id="toc-theorem-5.2.">Theorem 5.2.</a></li>
  <li><a href="#algorithm-5.1." id="toc-algorithm-5.1.">Algorithm 5.1.</a></li>
  </ul></li>
  <li><a href="#robust-adaptive-stabilization" id="toc-robust-adaptive-stabilization">5.3. Robust Adaptive Stabilization</a>
  <ul>
  <li><a href="#systems-with-relative-degree-one" id="toc-systems-with-relative-degree-one">5.3.1. Systems with Relative Degree One</a>
  <ul>
  <li><a href="#theorem-5.3" id="toc-theorem-5.3">Theorem 5.3</a></li>
  <li><a href="#corollary-5.1." id="toc-corollary-5.1.">Corollary 5.1.</a></li>
  </ul></li>
  <li><a href="#systems-with-high-relative-degree" id="toc-systems-with-high-relative-degree">5.3.2. Systems with High Relative Degree</a>
  <ul>
  <li><a href="#theorem-5.4." id="toc-theorem-5.4.">Theorem 5.4.</a></li>
  <li><a href="#algorithm-5.2." id="toc-algorithm-5.2.">Algorithm 5.2.</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
<section id="giriş.-basit-örnek" class="level1">
<h1>5.1. Giriş. Basit Örnek</h1>
<p>Adaptif kontrol problemini bu bölümde tanıtmak için, önce aşağıdaki formdaki basit bir doğrusal olmayan sistemi ele alıyoruz:</p>
<p><span class="math display">\[
\dot{x} = f^{T}(x,t)\mu + u \tag{5.1}
\]</span></p>
<p>Burada <span class="math inline">\(x\in \mathbb{R}\)</span> state; <span class="math inline">\(u \in \mathbb{R}\)</span> input; <span class="math inline">\(f : \mathbb{R}\times [t_0,\infty] \mapsto \mathbb{R}^{l}\)</span> <span class="math inline">\(x\)</span>’e göre yerel olarak Lipschitz koşulunu sağlayan ve <span class="math inline">\(t\)</span>’de uniform olan bilinen bir fonksiyondur ve <span class="math inline">\(\mu \in \mathbb{R}^{l}\)</span> bilinmeyen sabit bir parametre vektörüdür. <span class="math inline">\(\mu\)</span>’nun her bir bileşeninin herhangi bir reel değer almasına izin veriyoruz. Dolayısıyla, eğer <span class="math display">\[
g(x,d(t)) = f^{T}(x,t)\mu \tag{5.2}
\]</span> olarak tanımlarsak ve <span class="math inline">\(d(t) = (t,\mu)\)</span> alınır, ve <span class="math inline">\(d\)</span> sınırsızdır (unbounded) ve Bölüm 4’teki yaklaşım çalışmaz.</p>
<p>(5.2) biçimindeki belirsiz bir fonksiyonun, doğrusal parametreleştirme özelliğini (linear parameterization property) sağladığı söylenir; çünkü herhangi bir reel sayı <span class="math inline">\(\gamma\)</span> için <span class="math inline">\(f^{T}(x,t)(\gamma \mu) = \gamma \big(f^{T}(x,t)\mu\big)\)</span> eşitliği geçerlidir. Buna karşılık, <span class="math inline">\(x\in \mathbb{R}\)</span> ve <span class="math inline">\(\mu\)</span> sabit bir reel sayı olmak üzere, belirsiz fonksiyon <span class="math inline">\(\sin(\mu x)\)</span> doğrusal parametreleştirme özelliğini sağlamaz.</p>
<p>(5.1) numaralı sistemde, eğer μ biliniyor olsaydı, aşağıdaki kontrol yasası <span class="math display">\[
u = - f^T(x,t) \mu - \rho x, \quad \rho&gt;0 \tag{5.3}
\]</span> kapalı çevrim sistemi <span class="math inline">\(\dot{x} = -\rho x\)</span> şeklinde verir; bu da asimptotik olarak kararlı doğrusal bir sistemdir. Ancak <span class="math inline">\(\mu\)</span> bilinmediğinden, kontrol yasası (5.3) uygulanamaz. Bunun yerine aşağıdaki kontrol yasasını ele alacağız: <span class="math display">\[
u = - f^{T}(x,t)\hat{\mu} - \rho x, \quad \rho &gt; 0 \tag{5.4}
\]</span> Burada <span class="math inline">\(\hat{\mu} \in \mathbb{R}^{l}\)</span> <span class="math inline">\(\mu\)</span>’nun bir tahmini (estimation) olarak görülen sabit bir vektördür. Bu kontrol yasası altında, kapalı çevrim sistem <span class="math display">\[
\dot{x} = - f^{T}(x,t)\tilde{\mu} - \rho x \tag{5.5}
\]</span> şeklindedir; burada <span class="math inline">\(\tilde{\mu} = \hat{\mu} - \mu\)</span> parametre tahmin hatası olarak adlandırılır. Şimdi, <span class="math inline">\(l=1\)</span> ve <span class="math inline">\(f(x,t) = x\)</span> olan (5.5)’in en basit durumunu ele alalım. Bu durumda, (5.5) aşağıdaki doğrusal sisteme indirgenir.</p>
<p><span class="math display">\[
\dot{x} = -(\tilde{\mu} + \rho)x. \tag{5.6}
\]</span> Şimdi, <span class="math inline">\(\mu\)</span> keyfi olarak büyük değerler alabileceğinden, <span class="math inline">\(\rho\)</span> ne kadar büyük seçilirse seçilsin, (5.6)’nın kararlılığı garanti edilemez; çünkü <span class="math inline">\(\tilde{\mu} + \rho &gt; 0\)</span> koşulu garanti edilemez. Dolayısıyla, (5.4) biçimindeki statik durum geri beslemeli kontrol yasası bu durum için çalışmaz. Bunun ardından, aşağıdaki dinamik durum geri beslemeli kontrol yasasına geçiyoruz:</p>
<p><span class="math display">\[
u = - f^{T}(x,t)\hat{\mu} - \rho x, \quad \rho &gt; 0
\]</span></p>
<p><span class="math display">\[
\dot{\hat{\mu}} = \Lambda x f(x,t)
\tag{5.7}
\]</span></p>
<p>Burada <span class="math inline">\(\hat{\mu} \in \mathbb{R}^l\)</span> sabit bir vektör değil, (5.7)’nin ikinci denklemi tarafından yönetilen zamana bağlı bir fonksiyondur ve <span class="math inline">\(\Lambda \in \mathbb{R}^{l \times l}\)</span> simetrik ve pozitif tanımlı (positive definite) sabit bir matristir. <span class="math inline">\(\hat{\mu}, \mu\)</span>’nun dinamik tahmini (dynamic estimation) veya kısaca tahmin olarak adlandırılır; (5.7)’nin ikinci denklemi ise parametre güncelleme yasası (parameter update law) ya da kısaca güncelleme yasası olarak adlandırılır. (5.1) numaralı sistem ile (5.7) numaralı kontrol yasasının birleşimi, kapalı çevrim (closed-loop) sistem olarak adlandırılır ve aşağıdaki şekli alır:</p>
<p><span class="math display">\[
\begin{aligned}
\dot{x} &amp;= - f^{T}(x,t)\hat{\mu} - \rho x \\
\dot{\hat{\mu}} &amp;= \Lambda x f(x,t)
\end{aligned}
\tag{5.8}
\]</span></p>
<p>Şimdi, kapalı çevrim sistemin şu özelliğe sahip olduğunu göstereceğiz: herhangi bir başlangıç koşulu <span class="math inline">\(x(0)\)</span> ve <span class="math inline">\(\hat{\mu}(0)\)</span> için, kapalı çevrim sistemin (5.8) çözümü sınırlıdır ve <span class="math inline">\(\lim_{t \to \infty} x(t) = 0\)</span> olur. Bu amaçla, kapalı çevrim sistemi (5.8) için aşağıdaki Lyapunov fonksiyonu adayını ele alıyoruz:</p>
<p><span class="math display">\[
W(x, \tilde{\mu}) = x^2/2 + \tilde{\mu}^T \Lambda^{-1} \tilde{\mu}/2 \tag{5.9}
\]</span></p>
<p>Kapalı çevrim sistemin durum yörüngesi boyunca <span class="math inline">\(W(x, \tilde{\mu})\)</span> fonksiyonunun türevi</p>
<p><span class="math display">\[
\dot{W}(x, \tilde{\mu}) = x\dot{x} + \tilde{\mu}^T \Lambda^{-1} \dot{\tilde{\mu}} \\
= -\rho x^2 - \tilde{\mu}^T x f(x,t) + \tilde{\mu}^T \Lambda^{-1} \dot{\hat{\mu}} \\
= -\rho x^2 \le 0
\tag{5.10}
\]</span></p>
<p>Dolayısıyla, durum değişkenleri <span class="math inline">\(x\)</span> ve <span class="math inline">\(\hat{\mu}\)</span> sınırlıdır. Ayrıca, Teorem 2.5 uyarınca, <span class="math inline">\(\lim_{t \to \infty} x(t) = 0\)</span> elde edilir.</p>
<section id="theorem-5.1" class="level2">
<h2 class="anchored" data-anchor-id="theorem-5.1">Theorem 5.1</h2>
<p>Sistem (5.1) için küresel adaptif kararlılık problemi, aşağıdaki denetleyici tarafından çözülmektedir:</p>
<p><span class="math display">\[
u = -f^T(x,t)\hat{\mu} - \rho x, \quad \rho &gt; 0
\]</span></p>
<p><span class="math display">\[
\dot{\hat{\mu}} = \Lambda x f(x,t), \quad \Lambda = \Lambda^T &gt; 0
\]</span></p>
</section>
</section>
<section id="adaptive-stabilization.-tuning-functions." class="level1">
<h1>5.2. Adaptive stabilization. Tuning functions.</h1>
<p><strong>Küresel Adaptif Regülasyon Problemi (GARP)</strong> (2.7)-(2.9) şeklindeki doğrusal olmayan bir kontrol sistemi verildiğinde, (1.11) şeklinde bir denetliyici tasarla ki, kapalı çevrim sisteminin (2.10) herhangi bir başlanğıç koşulu <span class="math inline">\(x_c(0)\)</span> için, kapalı çevrim sisteminin durum yörüngesi <span class="math inline">\(x_c(t)\)</span> sınırlı kalsın ve <span class="math inline">\(lim_{t \rightarrow \infty} y(t) = 0\)</span> sağlansın. GARP tanımında, yalnızca performans çıktısı <span class="math inline">\(y\)</span>’nin asimptotik olarak orijine yaklaşması şart koşulmaktadır. Eğer <span class="math inline">\(y=x\)</span> ise, bu durumda GARP ayrıca <strong>Küresel Adaptif Kararlılık Problemi (GASP)</strong> olarak adlandırılır. Açıkça görülmektedir ki, sistem (5.1), <span class="math inline">\(y_m = y = x\)</span> olmak üzere (2.7)-(2.9) sistemlerinin özel bir durumudur.</p>
<div id="fig:example" class="figure">
<p><img src="eqs.png" class="img-fluid" style="width:60.0%"></p>
</div>
<p>Bu bölümde aşağıdaki lower triangular nonlinear sistemi ele alacağız:</p>
<p><span class="math display">\[\dot{x}_i = f_i^T(\vec{x_i}, t)\mu + x_{i+1}, \quad i=1,\dots, r \tag{5.13}\]</span> Burada <span class="math inline">\(\vec{x}_i = col(x_1,\dots, x_i)\)</span> state vektoru (<span class="math inline">\(x_i \in \mathbb{R}\)</span>); <span class="math inline">\(u := x_{r+1} \in \mathbb{R}\)</span> input ve <span class="math inline">\(\mu \in \mathbb{R}^l\)</span> bilinmeyen konstant parametre vektörüdür. <span class="math inline">\(r=1\)</span> olan fonksiyonu önceki bölümde inceledik. O örnekteki gibi, bizim asıl amacımız öyle bir controller ve update law bulmak ki, Lyapunov fonksiyonunun türevi negatif semi-definit olsun. Tasarım prosedürü r adımdan oluşmaktadır. Her bir adımda <span class="math inline">\(i =1, \dots, r\)</span> için öncdeki adımlara dayanarak iki fonksiyon, <span class="math inline">\(s_i\)</span> ve <span class="math inline">\(\tau_i\)</span> tasarlanır. Eğer sistemin relative derecesi <span class="math inline">\(i\)</span>-ye eşit olsaydı, bu iki fonksiyon sırasıyla denetim yasasını ve parametre güncelleme yasasını oluştururdu. Aksi halde, süreç yinelemeli (recursive) olarak <span class="math inline">\(i=r\)</span> oluncaya kadar devam eder; böylece gerçek denetim yasası (control law) <span class="math inline">\(x_{r+1} = S_r(.)\)</span> ve gerçek parametre güncelleme yasası <span class="math inline">\(\dot{\hat{\mu}} = \tau_r(.)\)</span> elde edilir. Literatürde <span class="math inline">\(\tau_i\)</span> fonksiyonları ayar (tuning) fonksiyonları olarak adlandırıldığından, bu tasarım yaklaşımı ayar fonksiyonları yaklaşımı (tuning functions approach) olarak isimlendirilir ve <em>Önerme 4.1</em>’in bir genellemesi olarak değerlendirilebilir.</p>
<p>Daha detaylı araştırma için aşağıdaki dinamik koordinat dönüşümünü tanımlayalım:</p>
<p><span class="math display">\[
\begin{aligned}
\chi_1 &amp;= x_1 \\
\chi_{i+1} &amp;= x_{i+1} - s_i(\vec{x}_i,\hat{\mu},t),
\qquad i = 1,\ldots,r \\
\dot{\hat{\mu}} &amp;= \tau_r(\vec{x}_r,\hat{\mu},t)
\end{aligned}
\tag{5.14}
\]</span> Burada <span class="math inline">\(s_i, i=1,\dots, r\)</span> ve <span class="math inline">\(\tau_r\)</span> yeterince düzgün (sufficiently smooth) fonksiyonlardır. Eğer <span class="math inline">\(\zeta_i = col(\vec{\chi}_i, \hat{\mu})\)</span> ve <span class="math inline">\(\vec{\chi}_i = col(\chi_1,..., \chi_i)\)</span> olarak tanımlanırsa, (5.13) ile verilen plant ve (5.14) ile verilen dönüşümden oluşan sistem <span class="math inline">\(\dot{\zeta}_r = \phi_r(\zeta_r, \chi_{r+1},t)\)</span> şeklinde ifade edilebilir. Bu durumda, <em>Proposition 4.1</em> aşağıdaki biçimde genelleştirilebilir.</p>
<p><strong>Proposition 5.1</strong> Eğer yeterince düzgün fonksiyonlar <span class="math inline">\(s_i, i=1,\dots, r\)</span> ve <span class="math inline">\(\tau_r\)</span> mevcut olup, kapalı çevrim sisteminin herhangi bir başlangıç koşulu <span class="math inline">\(\zeta_r(0)\)</span> için, <span class="math inline">\(\dot{\zeta} = \phi_r(\zeta_r, 0, t)\)</span> sisteminin durumu <span class="math inline">\(\zeta_r\)</span> sınırlı (bounded) kalıyor ve <span class="math inline">\(lim_{t \rightarrow \infty} {\vec{\chi_r}} = 0\)</span> sağlanıyorsa, o hâlde sistem (5.13) için <span class="math inline">\(y=x_1\)</span> olmak üzere Küresel Adaptif Regülasyon Problemi (GARP), aşağıdaki dinamik durum geri beslemeli denetleyici (closed loop feedback controller) ile çözülmüş olur:</p>
<p><span class="math display">\[
u = S_r(\vec{x}_r, \hat{\mu}, t) \quad \newline
\dot{\hat{\mu}} = \tau_r(\vec{x_r}, \hat{\mu}, t)
\tag{5.15}
\]</span> Buna ek olarak, eğer <span class="math inline">\(s_i(0,\hat{\mu}, t) = 0, \quad i=1,\dots, r-1\)</span> koşulu sağlanıyorsa, sistem (5.13) için <span class="math inline">\(y = \vec{\chi}_r\)</span>olmak üzere Küresel Adaptif Kararlılık Problemi (GASP) de aynı denetleyici tarafından çözülmüş olur.</p>
<p>Şimdi, <span class="math inline">\(i=1,\dots, r\)</span> için <span class="math inline">\(s_i\)</span> ve <span class="math inline">\(\tau_i\)</span> fonksiyonlarını elde etmek amacıyla özyinelemeli (recursive) bir prosedür tanıtıyoruz. <span class="math inline">\(s_1\)</span> ve <span class="math inline">\(\tau_1\)</span>’in inşası, önceki bölümden esinlenmiştir; yani,</p>
<p><span class="math display">\[
s_1(x_1, \hat{\mu}, t) = -f_1^T(x_1, t)\hat{\mu} - \rho_1 x_1, \quad \rho_1 \ge 5/4
\]</span> <span class="math display">\[
\tau_1(x_1, \hat{\mu}, t) = \Lambda x_1 f_1(x_1,t), \quad \Lambda = \Lambda^T &gt; 0
\tag{5.16}
\]</span></p>
<p>Kalan fonksiyonlar ise <span class="math inline">\(i=2,…,r\)</span> için aşağıdaki şekilde rekursiv olarak oluşturulur:</p>
<p><span class="math display">\[
\begin{align}
s_i(\vec{x}_i,\hat{\mu},t)
&amp;= - q_i^{\top}(\vec{x}_i,\hat{\mu},t)\,\hat{\mu}
   - \rho_i x_i
   + v_i(\vec{x}_i,\hat{\mu},t),
\\
&amp;\qquad \rho_i \ge \frac{9}{4}
\tag{5.17}
\end{align}
\]</span></p>
<p><span class="math display">\[
\begin{align}
\tau_i(\vec{x}_i,\hat{\mu},t)
&amp;= \tau_{i-1}(\vec{x}_{i-1},\hat{\mu},t)
   + \Lambda\, \chi_i\, q_i(\vec{x}_i,\hat{\mu},t)
\tag{5.18}
\end{align}
\]</span> Burada <span class="math inline">\(v_i\)</span> ve <span class="math inline">\(\varrho_i\)</span> aşağıdakı gibi tanımlanmıştır.</p>
<p><span class="math display">\[
\begin{align}
v_i(\vec{x}_i,\hat{\mu},t)
&amp;= \sum_{j=1}^{i-1}
   \frac{\partial s_{i-1}(\vec{x}_{i-1},\hat{\mu},t)}{\partial x_j}
   \, x_{j+1}
+ \frac{\partial s_{i-1}(\vec{x}_{i-1},\hat{\mu},t)}{\partial t}
\\[6pt]
&amp;\quad
+ \frac{\partial s_{i-1}(\vec{x}_{i-1},\hat{\mu},t)}{\partial \hat{\mu}}
   \, \tau_i(\vec{x}_i,\hat{\mu},t)
\\[6pt]
&amp;\quad
+ \sum_{j=1}^{i-2}
   x_{j+1}
   \frac{\partial s_j(\vec{x}_j,\hat{\mu},t)}{\partial \hat{\mu}}
   \, \Lambda \, \varrho_i(\vec{x}_i,\hat{\mu},t)
\tag{5.19}
\end{align}
\]</span></p>
<p><span class="math display">\[
\begin{align}
\varrho_i(\vec{x}_i,\hat{\mu},t)
&amp;= f_i(\vec{x}_i,t)
   - \sum_{j=1}^{i-1}
     \frac{\partial s_{i-1}(\vec{x}_{i-1},\hat{\mu},t)}{\partial x_j}
     \, f_j(\vec{x}_j,t)
\tag{5.20}
\end{align}
\]</span></p>
<p>Şimdi ise bu bölümün esas sonucunu aşağıdaki teorem ile özetleyebiliriz.</p>
<section id="theorem-5.2." class="level2">
<h2 class="anchored" data-anchor-id="theorem-5.2.">Theorem 5.2.</h2>
<p>Performans çıktısı <span class="math inline">\(y=x_1\)</span> olan sistem (5.13) için Küresel Adaptif Regülasyon Problemi (GARP), (5.16)–(5.18)’de tanımlanan ve ayrıca Algoritma 5.1’de özetlenen <span class="math inline">\(s_r\)</span> ve <span class="math inline">\(\tau_r\)</span> fonksiyonları kullanılarak, (5.15) ile verilen denetleyici tarafından çözülmektedir. Buna ek olarak, eğer <span class="math inline">\(f_i(0,t) = 0, \quad 1 = 1, \dots, r-1\)</span> koşulu sağlanıyorsa, performans çıktısı <span class="math inline">\(y = \vec{\chi}_r\)</span> olan sistem (5.13) için Küresel Adaptif Kararlılık Problemi (GASP) de aynı denetleyici tarafından çözülmektedir.</p>
</section>
<section id="algorithm-5.1." class="level2">
<h2 class="anchored" data-anchor-id="algorithm-5.1.">Algorithm 5.1.</h2>
<p><strong>Input:</strong> <span class="math inline">\(f_1, i=1,\dots, r\)</span>.</p>
<p><strong>Output:</strong> <span class="math inline">\(s_r \text{ ve } \tau_r\)</span>.</p>
<p><strong>Step 1:</strong> <span class="math inline">\(i = 1\)</span> için <span class="math inline">\(s_1, \tau_1\)</span> bul.</p>
<p><strong>Step 2:</strong> <span class="math inline">\(i = r\)</span> ise Step 5’e git, aksi takdirde Step 3’e git.</p>
<p><strong>Step 3:</strong> <span class="math inline">\(i = i + 1\)</span> için sırayla <span class="math inline">\(\varrho_i, \tau_i, v_i \text{ ve } s_i\)</span> değerlerini bul.</p>
<p><strong>Step 4:</strong> Step 2’ye git.</p>
<p><strong>Step 5:</strong> Son.</p>
<p><strong>Örnek 5.1</strong> Aşağıdaki ikinci dereceden doğrusal olmayan sistemi ele alalım:</p>
<p><span class="math display">\[
\dot{x_1} = x_1^2 \mu_1+x_2
\]</span> <span class="math display">\[
\dot{x_2} = sin(x_1 x_2)\mu_2 + u \\
\tag{5.24}
\]</span> burada <span class="math inline">\(\mu = [\mu_1 \quad \mu_2]^T\)</span> konstant parametre vektorudur. Amaç, performans çıktısı <span class="math inline">\(y = [x_1, x_2]^T\)</span> olan Küresel Adaptif Kararlılık Problemi (GASP)’ni çözen denetleyici <span class="math inline">\(u\)</span>’yu bulmaktır.</p>
<p>Denetleyiciyi açıkça inşa etmek için Algoritma 5.1-i izlememiz lazım. İlk adım, (5.16)’ya dayanarak aşağıdaki fonksiyonları seçmektir:</p>
<p><span class="math display">\[
s_1(x_1, \hat{\mu}) = -x_1^2 \hat{\mu}_1 - 2x_1 \\
\tau_1(x_1, \hat{\mu}) = [x_1^2 \quad 0] ^T
\]</span></p>
<p>Bir sonraki adımda, (5.17)–(5.20) numaralı bağıntılar kullanılarak sırasıyla <span class="math inline">\(q_2, \tau_2, v_2\)</span> ve <span class="math inline">\(s_2\)</span> hesaplanacaktır.</p>
<p><span class="math display">\[
\begin{align}
\varrho_2(\vec{x}_2,\hat{\mu})
= f_2(\vec{x}_2)
   - \frac{\partial s_1(\vec{x}_1,\hat{\mu})}{\partial x_1}\,
     f_1(\vec{x}_1)
\\
=
\begin{bmatrix}
(2 x_1 \hat{\mu}_1 + 2)\, x_1^2 &amp;
\sin(x_1 x_2)
\end{bmatrix}^{\top}
\end{align}
\]</span></p>
<p>daha sonra</p>
<p><span class="math display">\[
\begin{align}
\tau_2(\vec{x}_2,\hat{\mu})
&amp;= \tau_1(x_1,\hat{\mu})
   + \bigl[x_2 - s_1(x_1,\hat{\mu})\bigr]\,
     \varrho_2(\vec{x}_2,\hat{\mu})
\\[8pt]
&amp;=
\begin{bmatrix}
x_1^3
+ (2 x_1 \hat{\mu}_1 + 2)\, x_1^2
  \bigl(x_2 + x_1^2 \hat{\mu}_1 + 2 x_1\bigr)
\\[6pt]
\sin(x_1 x_2)\,
\bigl(x_2 + x_1^2 \hat{\mu}_1 + 2 x_1\bigr)
\end{bmatrix}.
\end{align}
\]</span></p>
<p>Elde ettiğimiz fonksiyonlarla <span class="math inline">\(v_2\)</span> ve <span class="math inline">\(s_2\)</span>-yi de bulalım.</p>
<p><span class="math display">\[
\begin{align}
v_2(\vec{x}_2,\hat{\mu})
&amp;=
\frac{\partial s_1(\vec{x}_1,\hat{\mu})}{\partial x_1}\, x_2
+ \frac{\partial s_1(\vec{x}_1,\hat{\mu})}{\partial \hat{\mu}}\,
  \tau_2(\vec{x}_2,\hat{\mu})
\\[8pt]
&amp;=
- (2 x_1 \hat{\mu}_1 + 2)\, x_2
-
\begin{bmatrix}
x_1^2 &amp; 0
\end{bmatrix}
\begin{bmatrix}
x_1^3
+ (2 x_1 \hat{\mu}_1 + 2)\, x_1^2
  (x_2 + x_1^2 \hat{\mu}_1 + 2 x_1)
\\[6pt]
\sin(x_1 x_2)\,
(x_2 + x_1^2 \hat{\mu}_1 + 2 x_1)
\end{bmatrix}
\\[10pt]
&amp;=
- (2 x_1 \hat{\mu}_1 + 2)\, x_2
- x_1^4
\Bigl(
x_1
+ (2 x_1 \hat{\mu}_1 + 2)
  (x_2 + x_1^2 \hat{\mu}_1 + 2 x_1)
\Bigr).
\end{align}
\]</span> ve</p>
<p><span class="math display">\[
\begin{align}
s_2(\vec{x}_2,\hat{\mu})
&amp;=
- \varrho_2^{\top}(\vec{x}_2,\hat{\mu})\,\hat{\mu}
- \rho_2 \bigl[x_2 - s_1(x_1,\hat{\mu})\bigr]
+ v_2(\vec{x}_2,\hat{\mu})
\\[10pt]
&amp;=
-
\begin{bmatrix}
(2 x_1 \hat{\mu}_1 + 2)\, x_1^2 &amp;
\sin(x_1 x_2)
\end{bmatrix}
\hat{\mu}
- \frac{9}{4}\,\bigl(x_2 + x_1^2 \hat{\mu}_1 + 2 x_1\bigr)
\\[6pt]
&amp;\quad
- (2 x_1 \hat{\mu}_1 + 2)\, x_2
- x_1^4
\Bigl(
x_1
+ (2 x_1 \hat{\mu}_1 + 2)
  \bigl(x_2 + x_1^2 \hat{\mu}_1 + 2 x_1\bigr)
\Bigr).
\end{align}
\]</span></p>
<p>Şimdi ise kontrolcüyü tasarlayabiliriz:</p>
<p><span class="math display">\[
u = s_2(\vec{x_2}, \hat{\mu})\\
\dot{\hat{\mu}} = \tau_2(\vec{x}_2, \hat{\mu})
\]</span></p>
<p>Denetleyicinin performansı <span class="math inline">\(\mu = [2,4]^T\)</span> için aşağıda gösterilmiştir. Başlangıç durum değerleri <span class="math inline">\(x(0) = [-2, 18]^T\)</span> ve <span class="math inline">\(\hat{\mu}(0) = [0,10]^T\)</span> olarak seçilmiştir. Kapalı çevrim sisteminin durum vektörü x’in, asimptotik olarak orijindeki denge noktasına yakınsadığı ve tahmin edilen parametre vektörü <span class="math inline">\(\hat{\mu}\)</span>’nun sınırlı kaldığı, ancak gerçek parametre değeri <span class="math inline">\(\mu\)</span>’ye yakınsamadığı gözlemlenmektedir.</p>
<p><img src="images/clipboard-3414064342.png" class="img-fluid"></p>
</section>
</section>
<section id="robust-adaptive-stabilization" class="level1">
<h1>5.3. Robust Adaptive Stabilization</h1>
<p>Bu bölümde, hem bozucular hem de bilinmeyen parametreler içeren belirsiz doğrusal olmayan sistemlerin bir sınıfını ele almak için robust ve adaptif teknikleri birleştiriyoruz. Sistemler aşağıdaki gibi tanımlanmaktadır:<br>
</p>
<p><span class="math display">\[
\begin{equation}\begin{aligned}\dot{z} &amp;= q\bigl(z, x_1, d(t)\bigr) \\\dot{x}_1 &amp;= f_1\bigl(z, x_1, d(t)\bigr) + b f_a^{T}(x_1,t)\mu + b x_2 \\\dot{x}_i &amp;= f_i(\vec{x}_i) + x_{i+1}, \quad i = 2, \ldots, r\end{aligned}\tag{5.25}\end{equation}
\]</span></p>
<p>Burada <span class="math inline">\(z \in \mathbb{R}^n\)</span> ve <span class="math inline">\(\vec{x}_i = col(x_1, ..., x_i)\)</span> olup <span class="math inline">\(x_i \in \mathbb{R}, i = 1,...,r\)</span> olmak üzere durum değişkenleridir. <span class="math inline">\(u := x_{r+1}\)</span> girdidir. <span class="math inline">\(\mu \in \mathbb{R}^{l_1}\)</span> bilinmeyen sabit parametredir ve <span class="math inline">\(d:[0, \infty] \rightarrow \mathbb{D} \subset \mathbb{R}^{l_2}\)</span> olup, burada <span class="math inline">\(\mathbb{D}\)</span> kompakt bir kümedir ve bilinmeyen parametreleri veya bozucuları temsil eder. Fonksiyonlar <span class="math inline">\(q, f_a, f_i, i = 1, ... , r\)</span> yeterince düzgündür (türevleri var) ve aşağıdaki koşulları sağlar:</p>
<p><span class="math display">\[
\begin{equation}\begin{aligned}q(0,0,d) &amp;= 0 \\f_1(0,0,d) &amp;= 0, \quad \text{tüm } d \in \mathbb{D} \text{ için} \\f_i(0) &amp;= 0, \quad i = 2, \ldots, r\end{aligned}\end{equation}
\]</span></p>
<p>Alt index <span class="math inline">\(a\)</span>, <span class="math inline">\(f_a^T(x_1, t)\mu\)</span> teriminin adaptif kontrol ile ele alınacağını ifade eder. (5.25)’te, <span class="math inline">\(q\)</span> fonksiyonu tam olarak bilinmeyebilir ve/veya <span class="math inline">\(z\)</span> durumu geri besleme kontrolü için kullanılmayabilir. Bu nedenle, <span class="math inline">\(z\)</span>’yi yöneten dinamikler dinamik belirsizlik olarak kabul edilir. <span class="math inline">\(\mu = 0\)</span> olduğunda, sistem (5.25) bir önceki bölümde incelenen filtre genişletilmiş forma (filter extended form) indirgenir.</p>
<p><strong>Assumption 5.1</strong>.<span class="math inline">\(\bar{b} \geq b \geq \underline{b}\)</span> olacak şekilde iki pozitif sabit <span class="math inline">\(\bar{b}\)</span> ve <span class="math inline">\(\underline{b}\)</span> vardır.</p>
<section id="systems-with-relative-degree-one" class="level2">
<h2 class="anchored" data-anchor-id="systems-with-relative-degree-one">5.3.1. Systems with Relative Degree One</h2>
<p>Öncelikle, <strong>bağıl derecesi</strong> (relative degree) <span class="math inline">\(r=1\)</span> olan (5.25) numaralı sistemi ele alıyoruz; yani,</p>
<p><span class="math display">\[
\begin{equation}\begin{aligned}\dot{z} &amp;= q\bigl(z, x, d(t)\bigr) \\\dot{x} &amp;= f\bigl(z, x, d(t)\bigr) + b f_a^{T}(x,t)\mu + b u\end{aligned}\tag{5.26}\end{equation}
\]</span> <span class="math inline">\(y=x\)</span> durumunda ortaya çıkan non-trivial ters dinamikleri ele alabilmek için, Varsayım 4.1 ile aynı rolü oynayan aşağıdaki varsayıma ihtiyaç duyarız.</p>
<p><strong>Assumption 5.2</strong>. Alt sistem <span class="math display">\[
\dot{z}=q(z,x,d)
\]</span> için bir İSS Lyapunov fonksiyonu <span class="math inline">\(V(z)\)</span> vardır; yani</p>
<p><span class="math display">\[
\begin{equation}V(z) \sim \{ \underline{\alpha}, \bar{\alpha}, \alpha, \sigma \mid \dot{z} = q(z,x,d) \}\end{equation}
\]</span></p>
<p>ve</p>
<p><span class="math display">\[
\begin{equation}\limsup_{s \to 0^{+}} \frac{s^{2}}{\alpha(s)} &lt; \infty,\qquad\limsup_{s \to 0^{+}} \frac{\sigma(s)}{s^{2}} &lt; \infty\end{equation}
\]</span></p>
<p>İlk adım, Bölüm 4.2’deki prosedürü tekrarlamaktır. Özellikle, Appendix’teki (11.13) denklemi kullanılarak, yeterince düzgün ve negatif olmayan iki fonksiyon <span class="math inline">\(m_1\)</span>​ ve <span class="math inline">\(m_2\)</span>​ bulunabilir; öyle ki</p>
<p><span class="math display">\[
\begin{equation}\lvert f(z,x,d) \rvert \le m_1(z)\lVert z \rVert + m_2(x)\lvert x \rvert,\qquad \forall d \in \mathbb{D}\tag{5.27}\end{equation}
\]</span></p>
<p>Yeterince düzgün (sufficiently smooth) bir fonksiyon seçelim; öyle ki</p>
<p><span class="math display">\[
\begin{equation}\Delta(z) \ge 1 + m_1^{2}(z)\tag{5.28}\end{equation}
\]</span></p>
<p>Corrolary 2.2-ye göre, bazı sınıf <span class="math inline">\(K_{\infty}\)</span> fonksiyonlari <span class="math inline">\(\alpha'\)</span> ve <span class="math inline">\(\bar{\alpha}'\)</span> için</p>
<p><span class="math display">\[
\alpha'(\lVert z \rVert) \le V'(z) \le \bar{\alpha}'(\lVert z \rVert)
\]</span></p>
<p>koşulunu sağlayan, sürekli türevlenebilir bir fonksiyon <span class="math inline">\(V'(z)\)</span> mevcutttur. Bu fonksiyon, <span class="math inline">\(\dot{z} = q(z,x,d)\)</span> durum yörüngesi boyunca aşağıdaki eşitsizliği sağlar:</p>
<p><span class="math display">\[
\dot{V}'(z) \le -\Delta(z)\lVert z \rVert^{2} + \chi(x)x^{2}\tag{5.29}
\]</span></p>
<p>Burada <span class="math inline">\(\chi\)</span>, yeterince düzgün bir fonksiyondur. Daha sonra, aşağıdaki koşulu sağlayan yeterince düzgün bir fonksiyon <span class="math inline">\(\rho(x)\)</span> tanımlanır:</p>
<p><span class="math display">\[
\rho(x) \ge \bigl[\chi(x) + m_2(x) + 5/4\bigr]/b\tag{5.30}
\]</span></p>
<section id="theorem-5.3" class="level3">
<h3 class="anchored" data-anchor-id="theorem-5.3">Theorem 5.3</h3>
<p><span class="math inline">\(\mathbb{D}\)</span>-nin önceden verilmiş (prescribed) kompakt bir küme olduğu (5.26) numaralı sistemi ele alalım. Varsayım 5.1 ve Varsayım 5.2 altında, performans çıktısı <span class="math inline">\(y = \operatorname{col}(z, x)\)</span> olan (5.26) sisteminin GASP problemi, aşağıdaki kontrolcü ile çözülmektedir:</p>
<p><span class="math display">\[
u = - f_a^{T}(x, t)\hat{\mu} - \rho(x)x
\]</span></p>
<p><span class="math display">\[
\dot{\hat{\mu}} = \Lambda x f_a(x, t), \quad \Lambda = \Lambda^{T} &gt; 0 \tag{5.31}
\]</span></p>
<p>Burada <span class="math inline">\(\rho\)</span> fonksiyonu (5.30)’da verilmiştir.</p>
<p><strong>Ispat:</strong></p>
<p>Kapalı çevrim (closed-loop) sistem için aşağıdaki Lyapunov fonksiyonu adayını tanımlayalım:</p>
<p><span class="math display">\[
W(z, x, \tilde{\mu}) = V'(z) + x^2/2 + b\,\tilde{\mu}^T \Lambda^{-1} \tilde{\mu}/2
\]</span></p>
<p>Burada <span class="math inline">\(\tilde{\mu} = \hat{\mu} - \mu\)</span> parametre kestirim hatasıdır. Doğrudan hesaplama ile, kapalı çevrim sistemin durum yörüngesi boyunca <span class="math inline">\(W(z, x, \tilde{\mu})\)</span> fonksiyonunun türevinin aşağıdaki eşitsizlikleri sağladığı görülür:</p>
<p><span class="math display">\[
\begin{equation}\begin{aligned}\dot{W}(z,x,\tilde{\mu})&amp;\le -\Delta(z)\lVert z \rVert^{2}     + \chi(x)x^{2}     + x\bigl[f(z,x,d) + b f_a^{T}(x,t)\mu + b u\bigr]     + b\tilde{\mu}^{T}\Lambda^{-1}\dot{\hat{\mu}} \\[0.6em]&amp;\le -\Delta(z)\lVert z \rVert^{2}     + \chi(x)x^{2}     + x\bigl[f(z,x,d) - b\rho(x)x\bigr] \\[0.6em]&amp;\quad     + bx\bigl[f_a^{T}(x,t)\mu - f_a^{T}(x,t)\hat{\mu}\bigr]     + b\tilde{\mu}^{T}\Lambda^{-1}\dot{\hat{\mu}} \\[0.6em]&amp;\le -\Delta(z)\lVert z \rVert^{2}     + m_1^{2}(z)\lVert z \rVert^{2}     + x^{2}\bigl[\chi(x) + 1/4 + m_2(x) - b\rho(x)\bigr] \\[0.6em]&amp;\quad     + b\tilde{\mu}^{T}       \bigl(-x f_a(x,t) + \Lambda^{-1}\dot{\hat{\mu}}\bigr) \\[0.6em]&amp;\le -\lVert z \rVert^{2} - x^{2}.\end{aligned}\tag{5.32}\end{equation}
\]</span></p>
<p>Artık kapalı çevrim (closed-loop) sistemin kararlılığı, <strong>Teorem 2.5</strong> kullanılarak tesis edilebilir. Özellikle, <span class="math inline">\(\lim_{t \to \infty} \operatorname{col}(z(t), x(t)) = 0\)</span>olduğu elde edilir. Böylece GASP problemi çözülmüş olur. Son olarak, parametre <span class="math inline">\(\hat{\mu}\)</span>’nun yakınsama (convergence) problemi, aşağıdaki sonuç (corollary) ile gösterildiği şekilde ele alınacaktır.</p>
</section>
<section id="corollary-5.1." class="level3">
<h3 class="anchored" data-anchor-id="corollary-5.1.">Corollary 5.1.</h3>
<p>Teorem 5.3’te, verilen (5.26) numaralı sistem ile (5.31) numaralı kontrolörden oluşan kapalı çevrim sistem, herhangi bir başlangıç durumu için aşağıdaki özelliklere sahiptir:</p>
<p><span class="math display">\[
\lim_{t \to \infty} \dot{\hat{\mu}}(t) = 0, \tag{5.33}
\]</span></p>
<p>ve eğer <span class="math inline">\(d(t),\dot{d}(t),f_a(x, t)\)</span> <span class="math inline">\(\frac{\partial f_a(x, t)}{\partial t}\)</span> ve <span class="math inline">\(\frac{\partial f_a(x, t)}{\partial x}\)</span> tüm <span class="math inline">\(t \ge 0\)</span> için sınırlı (bounded) ise, o zaman</p>
<p><span class="math display">\[
\lim_{t \to \infty} f_a^{T}(0, t)\,(\hat{\mu}(t) - \mu) = 0. \tag{5.34}
\]</span></p>
<p>Ayrıca, eğer <span class="math inline">\(f_a(0, t)\)</span> kalıcı uyarım (persistently exciting, <strong>PE</strong>) özelliğine sahipse, o halde</p>
<p><span class="math display">\[
\lim_{t \to \infty} \hat{\mu}(t) = \mu. \tag{5.35}
\]</span></p>
<p><strong>Ispat</strong></p>
<p>Teorem 5.3’te, <span class="math inline">\(\lim_{t \to \infty} \operatorname{col}(z(t), x(t)) = 0\)</span> sonucunun ispatlandığı gösterilmiştir; bu da (5.33)’ü ima eder. <span class="math inline">\(d(t), \dot{d(t)}, f_a(x,t)\)</span>, <span class="math inline">\(\frac{\partial f_a(x, t)}{\partial t}\)</span> ve <span class="math inline">\(\frac{\partial f_a(x, t)}{\partial x}\)</span> fonksiyonları sınırlı olduğundan, <span class="math inline">\(\ddot{x}\)</span> sınırlıdır ve dolayısıyla <span class="math inline">\(\dot{x}\)</span> uniform süreklidir. <strong>Barbalat Lemması</strong> ile, <span class="math inline">\(\dot{x}(t) \to 0 \quad \text{iken } t \to \infty\)</span> elde edilir; bu da (5.34)’ü ima eder. Son olarak, <strong>Lemma 2.4</strong> ile, <span class="math inline">\(f_a(0, t)\)</span> kalıcı uyarım (PE) özelliğine sahipse (5.35) sağlanır</p>
</section>
</section>
<section id="systems-with-high-relative-degree" class="level2">
<h2 class="anchored" data-anchor-id="systems-with-high-relative-degree">5.3.2. Systems with High Relative Degree</h2>
<p>Bu bölümde, <span class="math inline">\(r &gt; 1\)</span> olan genel (5.25) numaralı sistemi ele alıyoruz. <span class="math inline">\(r &gt; 1\)</span> olduğunda, (5.25)’teki <span class="math inline">\(x_2\)</span>​ gerçek bir kontrol girdisi değildir; ancak Teorem 5.3’te verilen (5.31) numaralı kontrolör aşağıdaki koordinat dönüşümünü teşvik eder:</p>
<p><span class="math display">\[
\chi_2 = x_2 - s_1(x_1, \hat{\mu}, t), \quad s_1(x_1, \hat{\mu}, t) = - f_a^{T}(x_1, t)\hat{\mu} - \rho_1(x_1)x_1
\]</span></p>
<p>Burada <span class="math inline">\(\chi_2\)</span> aşağıdaki denklemle yönetilmektedir:</p>
<p><span class="math display">\[
\begin{equation}\begin{aligned}\dot{x}_2&amp;= f_2(\vec{x}_2) - \dot{s}_1(x_1,\hat{\mu},t) + x_3 \\[0.6em]&amp;= f_2(\vec{x}_2)   - \frac{\partial s_1(x_1,\hat{\mu},t)}{\partial x_1}     \bigl[       f_1(z,x_1,d)       + b f_a^{T}(x_1,t)\mu       + b x_2     \bigr] \\[0.6em]&amp;\quad   - \frac{\partial s_1(x_1,\hat{\mu},t)}{\partial \hat{\mu}}     \dot{\hat{\mu}}   - \frac{\partial s_1(x_1,\hat{\mu},t)}{\partial t}   + x_3 .\end{aligned}\tag{5.36}\end{equation}
\]</span></p>
<p>Burada <span class="math inline">\(\mu\)</span>-ya ek olarak, parametre <span class="math inline">\(b\)</span> de bilinmeyendir ve tahmin edilmesi gerekmektedir. <span class="math inline">\(\hat{b}\)</span>, <span class="math inline">\(b\)</span>’nin tahmini olarak kabuledilirse ve <span class="math inline">\(\tilde{b} = \hat{b} - b\)</span> ise tahmin hatası olur.</p>
<p>Tahmin <span class="math inline">\(\hat{b}\)</span>’nin tanıtılmasıyla birlikte, denetim yasasını tanımlayan çeşitli fonksiyonlar da <span class="math inline">\(\hat{b}\)</span>’ye bağlı olabilir. Bu nedenle, aşağıdaki dinamik koordinat dönüşümü tanımlanır:</p>
<p><span class="math display">\[
\begin{align}
\chi_1
&amp;= x_1,
\\[6pt]
\chi_{i+1}
&amp;= x_{i+1} - s_i(\vec{x}_i,\hat{\mu},\hat{b},t),
\qquad i = 1,\dots,r,
\\[8pt]
\dot{\hat{\mu}}
&amp;= \tau_r(\vec{x}_r,\hat{\mu},\hat{b},t),
\\[6pt]
\dot{\hat{b}}
&amp;= \varpi_r(\vec{x}_r,\hat{\mu},\hat{b},t).
\tag{5.37}
\end{align}
\]</span></p>
<p>Burada, daha sonra belirtilecek olan yeterince düzgün fonksiyonlar <span class="math inline">\(s_i, i=1,..,r, \tau_r \text{ ve } \omega_r\)</span> bulunmaktadır. <span class="math inline">\(\zeta_i = \operatorname{col}(\vec{\chi}_i, \hat{\mu}, \hat{b})\)</span> olarak tanımlansın. <span class="math inline">\(\zeta_r\)</span>`yi yöneten sistem <span class="math inline">\(\dot{\zeta}_r = \varphi_r(\zeta_r, \chi_{r+1}, t)\)</span> şeklinde gösterilsin.</p>
<p><strong>Proposition 5.2</strong><br>
Eğer <span class="math inline">\(i = 1, \ldots, r\)</span> için yeterince düzgün fonksiyonlar <span class="math inline">\(s_i\)</span> ve <span class="math inline">\(\tau_r\)</span> mevcutsa; öyle ki <span class="math inline">\(\dot{\zeta}_r = \varphi_r(\zeta_r, 0, t)\)</span> sistemin durumu <span class="math inline">\(\zeta_r\)</span> sınırlı (bounded) olsun ve <span class="math inline">\(\lim_{t \to \infty } \vec{\chi}_r = 0\)</span> sağlansın, o hâlde (5.25) numaralı sistem için performans çıktısı <span class="math inline">\(y = x_1\)</span> olan <strong>GARP</strong> problemi, aşağıda verilen dinamik kontrolör ile çözülmektedir.</p>
<p><span class="math display">\[
\begin{equation}\begin{aligned}u &amp;= s_r(\vec{x}_r,\hat{\mu},\hat{b},t) \\\dot{\hat{\mu}} &amp;= \tau_r(\vec{x}_r,\hat{\mu},\hat{b},t) \\\dot{\hat{b}} &amp;= \varpi_r(\vec{x}_r,\hat{\mu},\hat{b},t)\end{aligned}\tag{5.38}\end{equation}
\]</span></p>
<p>Ayrıca, <span class="math inline">\(i = 1, \dots, r-1\)</span> için <span class="math inline">\(S_i(0, \mu, \hat{b}, t) = 0\)</span> olmasi halinde (5.25) numaralı sistem için performans çıktısı <span class="math inline">\(y = \vec{x}_r\)</span> olan <strong>GASP</strong> problemi, aynı kontrolcü ile çözülmektedir..</p>
<p>Bu problemde de <span class="math inline">\(S_r, \tau_r\)</span> ve <span class="math inline">\(\omega_r\)</span> denklemlerini rekursiv şekilde bulmamız gerekiyor. <span class="math inline">\(r=1\)</span> olduğunda ilk adım bundan önceki örnekte verildiği gibi olacaktır.</p>
<p>Bölüm 5.2’de olduğu gibi, <span class="math inline">\(s_r\)</span>, <span class="math inline">\(\tau_r\)</span>​ ve <span class="math inline">\(\varpi_r\)</span> fonksiyonlarını özyinelemeli (recursive) olarak bulmamız gerekmektedir. İlk adım, <span class="math inline">\(r = 1\)</span> olan önceki durumdan esinlenmiştir. Yine, Ek’teki (11.13) bağıntısına göre aşağıdakinin geçerli olduğunu not ederiz:</p>
<p><span class="math display">\[
|f_1(z, x_1, d)| \le m_1(z)\|z\| + m_2(x_1)|x_1|, \quad \forall d \in \mathbb{D} \tag{5.39}
\]</span></p>
<p>Burada <span class="math inline">\(m_1\)</span>​ ve <span class="math inline">\(m_2\)</span>​, yeterince düzgün (sufficiently smooth) ve negatif olmayan bazı fonksiyonlardır. Şimdi</p>
<p><span class="math display">\[
\dot{z} = q(z, x_1, d)  \tag{5.40}
\]</span></p>
<p>kabuledelim.</p>
<p>Varsayım 5.2 altında, değişen besleme (changing supply) fonksiyonu tekniği (Sonuç 2.2) kullanılarak, bazı sınıf <span class="math inline">\(\mathcal{K}_\infty\)</span>​ fonksiyonları <span class="math inline">\(\alpha'\)</span> ve <span class="math inline">\(\bar{\alpha'}\)</span> için</p>
<p><span class="math display">\[
\alpha'(\|z\|) \le V'(z) \le \bar{\alpha}'(\|z\|)
\]</span></p>
<p>koşulunu sağlayan sürekli türevlenebilir bir fonksiyon <span class="math inline">\(V'(z)\)</span> mevcuttur; öyle ki,</p>
<p><span class="math display">\[
\dot{z} = q(z, x_1, d)
\]</span></p>
<p>durum yörüngesi boyunca aşağıdaki eşitsizlik sağlanır:</p>
<p><span class="math display">\[
\dot{V}'(z) \le -\Delta(z)\|z\|^2 + \chi(x_1)x_1^2 \tag{5.41}
\]</span></p>
<p>Burada <span class="math inline">\(\chi\)</span> yeterince düzgün ve negatif olmayan bir fonksiyondur. Eğer,</p>
<p><span class="math display">\[
\rho_1(x_1) \ge \big[\chi(x_1) + m_2(x_1) + 5/4 + (r-1)m_2^2(x_1)\big]/\underline{b} + \bar{b}/4 \tag{5.42}
\]</span></p>
<p>kabuledersek, <span class="math inline">\(r=1\)</span> icin aşağıdaki denklemleri yazabiliriz.</p>
<p><span class="math display">\[
\begin{equation}\begin{aligned}s_1(x_1,\hat{\mu},\hat{b},t)&amp;= - f_a^{T}(x_1,t)\hat{\mu} - \rho_1(x_1)x_1 \\\tau_1(x_1,\hat{\mu},\hat{b},t)&amp;= \Lambda_{\mu} x_1 f_a(x_1,t) \\\varpi_1(x_1,\hat{\mu},\hat{b},t)&amp;= 0\end{aligned}\tag{5.43}\end{equation}
\]</span></p>
<p><span class="math inline">\(r=2,\dots,r\)</span> için gereken denklemleri ise aşağıdaki gibi yazabiliriz:</p>
<p><span class="math display">\[
\begin{equation}\begin{aligned}s_i(\vec{x}_i,\hat{\mu},\hat{b},t)&amp;= q_i(\vec{x}_{i-1},\hat{\mu},\hat{b},t)   - \rho_i(\vec{x}_{i-1},\hat{\mu},\hat{b},t)\,\chi_i   + \nu_i(\vec{x}_i,\hat{\mu},\hat{b},t) \\[0.6em]\tau_i(\vec{x}_i,\hat{\mu},\hat{b},t)&amp;= \tau_{i-1}(\vec{x}_{i-1},\hat{\mu},\hat{b},t)   - \Lambda_{\mu}\,\chi_i\,     \frac{\partial s_{i-1}(\vec{x}_{i-1},\hat{\mu},\hat{b},t)}{\partial x_1}\,     f_a(x_1,t) \\[0.6em]\varpi_i(\vec{x}_i,\hat{\mu},\hat{b},t)&amp;= \varpi_{i-1}(\vec{x}_{i-1},\hat{\mu},\hat{b},t)   - \Lambda_b\,\chi_i\,     \frac{\partial s_{i-1}(\vec{x}_{i-1},\hat{\mu},\hat{b},t)}{\partial x_1}\,     \bigl[f_a^{T}(x_1,t)\hat{\mu} + x_2\bigr]\end{aligned}\tag{5.44}\end{equation}
\]</span></p>
<p>Burada</p>
<p><span class="math display">\[
\begin{equation}\begin{aligned}\varrho_i(\vec{x}_{i-1},\hat{\mu},\hat{b},t)&amp;=\Biggl( - \sum_{j=1}^{i-2}   x_{j+1}\,   \frac{\partial s_j(\vec{x}_j,\hat{\mu},\hat{b},t)}{\partial \hat{\mu}}\,   \Lambda_{\mu}\Biggr)\frac{\partial s_{i-1}(\vec{x}_{i-1},\hat{\mu},\hat{b},t)}{\partial x_1}\, f_a(x_1,t) \\[0.8em]&amp;\quad+\Biggl( \hat{b} - \sum_{j=1}^{i-2}   x_{j+1}\,   \frac{\partial s_j(\vec{x}_j,\hat{\mu},\hat{b},t)}{\partial \hat{b}}\,   \Lambda_{b}\Biggr)\frac{\partial s_{i-1}(\vec{x}_{i-1},\hat{\mu},\hat{b},t)}{\partial x_1}\bigl[  f_a^{T}(x_1,t)\hat{\mu} + x_2\bigr]\end{aligned}\end{equation}
\]</span></p>
<p>ve</p>
<p><span class="math display">\[
\begin{equation}\begin{aligned}\nu_i(\vec{x}_i,\hat{\mu},\hat{b},t)&amp;= - f_i(\vec{x}_i)   + \sum_{j=2}^{i-1}     \frac{\partial s_{i-1}(\vec{x}_{i-1},\hat{\mu},\hat{b},t)}{\partial x_j}     \bigl[       f_j(\vec{x}_j) + x_{j+1}     \bigr] \\[0.8em]&amp;\quad   + \frac{\partial s_{i-1}(\vec{x}_{i-1},\hat{\mu},\hat{b},t)}{\partial \hat{\mu}}\,     \tau_i(\vec{x}_i,\hat{\mu},\hat{b},t) \\[0.8em]&amp;\quad   + \frac{\partial s_{i-1}(\vec{x}_{i-1},\hat{\mu},\hat{b},t)}{\partial \hat{b}}\,     \varpi_i(\vec{x}_i,\hat{\mu},\hat{b},t) \\[0.8em]&amp;\quad   + \frac{\partial s_{i-1}(\vec{x}_{i-1},\hat{\mu},\hat{b},t)}{\partial t}.\end{aligned}\end{equation}
\]</span></p>
<p>Yukardaki denklemlerde <span class="math inline">\(\Lambda_\mu = \Lambda_\mu^{T} &gt; 0\)</span> ve scalar <span class="math inline">\(\Lambda_b &gt; 0\)</span> arbitrarily seçilebilir. Ayrıca <span class="math inline">\(i \geq 2\)</span> için <span class="math inline">\(S_i(\vec{x}_i, \hat{\mu}, \hat{b}, t)\)</span> fonksiyonunun, aşağıdaki teoremin ispatını kolaylaştırmak amacıyla üç terime ayrıldığına dikkat edilir.</p>
<section id="theorem-5.4." class="level3">
<h3 class="anchored" data-anchor-id="theorem-5.4.">Theorem 5.4.</h3>
<p><span class="math inline">\(\mathbb{D}\)</span>`nin önceden verilmiş (prescribed) kompakt bir küme olduğu (5.25) numaralı sistemi ele alalım. Varsayım 5.1-i ve Varsayım 5.2-i ele alarak, <span class="math inline">\(y = \operatorname{col}(z, x_1)\)</span> olan (5.25) sisteminin <strong>GARP</strong> problemi (5.38) numaralı kontröler ile çözülmektedir; burada <span class="math inline">\(s_r\)</span> ve <span class="math inline">\(\tau_r\)</span> fonksiyonları (5.43)-(5.44)’le tanımlanmış olup ayrıca Algoritma 5.2’de özetlenmiştir. Ayrıca, eğer <span class="math inline">\(f_a(0, t) = 0\)</span> ise performans çıktısı <span class="math inline">\(y = \operatorname{col}(z, \vec{x}_r)\)</span> olan (5.25) sisteminin <strong>GASP</strong> problemi de aynı kontrolcü ile çözülmektedir.</p>
</section>
<section id="algorithm-5.2." class="level3">
<h3 class="anchored" data-anchor-id="algorithm-5.2.">Algorithm 5.2.</h3>
<p><strong>Input 5.2:</strong> <span class="math inline">\(f_i, i=1,\dots, r, f_a, \bar{b}, \underline{b}, \underline{\alpha}, \bar{\alpha}, \alpha, \sigma,\mathbb{D}\)</span></p>
<p><strong>Output:</strong> <span class="math inline">\(s_r, \tau_r\)</span> ve <span class="math inline">\(\varpi_r\)</span></p>
<p><strong>Step 1:</strong> Verilen <span class="math inline">\(f_1(z,x_1, d)\)</span> için (5.39)-cu denklemleri kullanarak <span class="math inline">\(m_1\)</span> ve <span class="math inline">\(m_2\)</span>-ni bul.</p>
<p><strong>Step 2:</strong> (5.40) denkleminden <span class="math inline">\(\Delta\)</span> - nı bul ve <span class="math inline">\(\underline{\alpha}', \bar{\alpha}', \chi = \text{algorithm 2.3} (\underline{\alpha}, \bar{\alpha}, \alpha, \sigma, \Delta)\)</span>.</p>
<p><strong>Step 3:</strong> <span class="math inline">\(i=1\)</span> olduğunda (5.43)’ü kullanarak <span class="math inline">\(s_1\)</span> ve <span class="math inline">\(\tau_1\)</span>’i bul.</p>
<p><strong>Step 4:</strong> <span class="math inline">\(i=r\)</span> olduğunda, Step 7’e git, aksi takdirde Step 5’e git.</p>
<p><strong>Step 5:</strong> <span class="math inline">\(i=i+1\)</span> olduğunda, (5.44)’cü denklemlerden <span class="math inline">\(s_i, \tau_i\)</span> ve <span class="math inline">\(\varpi_i\)</span> değerlerini bul.</p>
<p><strong>Step 6:</strong> Step 4’e git.</p>
<p><strong>Step 7:</strong> Son.</p>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>